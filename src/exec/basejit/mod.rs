//! A baseline JIT compiler using the bytecode infrastructure.

use std::{mem, ptr};

use crate::{
    bc::{self, Program},
    ir,
    runtime::Context,
    CellType, Error,
};

use super::{Executable, Executor};

mod asm;
mod codegen;

use asm::*;

/// Function type of the generated JIT function.
type HpbfEntry<'a, C> = unsafe extern "sysv64" fn(cxt: *mut Context<'a, C>, mem: *mut C) -> bool;

/// A baseline compiler that does some limited optimizing transformations of the
/// program and executes the result using a simple JIT compiler.
///
/// # Examples
/// ```
/// # use hpbf::{ir::{Program, Block, Instr}, Error, runtime::Context, exec::{Executor, Executable, BaseJitCompiler}};
/// # let mut buf = Vec::new();
/// # let mut ctx = Context::<u8>::new(None, Some(Box::new(&mut buf)));
/// # let code = "++++++[>+++++<-]>++[>++<-]++++[>++<-]>[.>]";
/// let exec = BaseJitCompiler::<u8>::create(code, 1)?;
/// exec.execute(&mut ctx)?;
/// # drop(ctx);
/// # assert_eq!(String::from_utf8(buf).unwrap(), "H");
/// # Ok::<(), Error>(())
/// ```
pub struct BaseJitCompiler<C: CellType> {
    bytecode: Program<C>,
}

/// Struct implementing the compilation.
/// Current register usage:
///   rsp -> stack pointer used for temps >= 11
///   rbx -> context pointer
///   rbp -> memory pointer
///   rax,rcx -> used for intermediate values
///   others -> temps < 11
struct CodeGen {
    locations: Vec<usize>,
    reloc_br: Vec<(usize, usize)>,
    reloc_term: Vec<usize>,
    term: usize,
    code: Vec<u8>,
}

impl<C: CellType> BaseJitCompiler<C> {
    /// Return the machine code generated by this compiler.
    pub fn print_mc(&self, limit: bool) -> Vec<u8> {
        self.compile_program(limit)
    }

    /// Generate, from the bytecode, the corresponding machine code.
    fn compile_program(&self, limited: bool) -> Vec<u8> {
        let mut code_gen = CodeGen {
            locations: Vec::new(),
            reloc_br: Vec::new(),
            reloc_term: Vec::new(),
            term: 0,
            code: Vec::new(),
        };
        code_gen.emit_prologue(self.bytecode.temps);
        code_gen.emit_program(&self.bytecode, limited);
        code_gen.emit_epilogue(self.bytecode.temps);
        code_gen.fix_relocations();
        code_gen.code
    }

    /// Allocate executable memory, copy the code into it, and enter the JITed code.
    /// We allocate memory using mmap, which is the reason why this module is only
    /// available on unix-like platforms.
    fn enter_jit_code(&self, cxt: &mut Context<C>, code: Vec<u8>) -> bool {
        cxt.memory
            .make_accessible(self.bytecode.min_accessed, self.bytecode.max_accessed + 1);
        // Lets guess the page size is 4 or 16 KiB.
        const PAGE_SIZE: usize = 1 << 14;
        let result;
        unsafe {
            let len = (code.len() + PAGE_SIZE) & !(PAGE_SIZE - 1);
            let code_mem = libc::mmap(
                ptr::null_mut(),
                len,
                libc::PROT_EXEC | libc::PROT_READ | libc::PROT_WRITE,
                libc::MAP_ANONYMOUS | libc::MAP_PRIVATE,
                0,
                0,
            ) as *mut u8;
            assert!(
                code_mem as isize != -1,
                "failed mmap executable memory region"
            );
            ptr::copy_nonoverlapping(code.as_ptr(), code_mem, code.len());
            let mem_ptr = cxt.memory.current_ptr();
            let entry = mem::transmute::<_, HpbfEntry<C>>(code_mem);
            result = entry(cxt, mem_ptr);
            assert!(
                libc::munmap(code_mem as *mut _, len) == 0,
                "failed to munmap jit memory"
            );
        }
        result
    }

    /// Execute in the given context using the JIT compiler.
    fn execute_in<'a>(&self, cxt: &mut Context<'a, C>, limited: bool) -> bool {
        let code = self.compile_program(limited);
        self.enter_jit_code(cxt, code)
    }
}

impl<'code, C: CellType> Executor<'code, C> for BaseJitCompiler<C> {
    fn create(code: &str, opt: u32) -> Result<Self, Error> {
        let mut program = ir::Program::<C>::parse(code)?;
        program = program.optimize(opt);
        let bytecode = bc::CodeGen::translate(&program, 11, false);
        Ok(BaseJitCompiler { bytecode })
    }
}

impl<C: CellType> Executable<C> for BaseJitCompiler<C> {
    fn execute(&self, context: &mut Context<C>) -> Result<(), Error> {
        self.execute_in(context, false);
        Ok(())
    }

    fn execute_limited(&self, context: &mut Context<C>) -> Result<bool, Error> {
        Ok(self.execute_in(context, true))
    }
}

/// Runtime function. Extends the memory buffer and moves the offset to make the range
/// from `min` (inclusive) to `max` (exclusive) accessible.
extern "sysv64" fn hpbf_context_extend<C: CellType>(
    cxt: &mut Context<'static, C>,
    min: isize,
    max: isize,
) {
    cxt.memory.make_accessible(min, max);
}

/// Runtime function. Get a value form the input, or zero in case the input closed.
extern "sysv64" fn hpbf_context_input<C: CellType>(cxt: &mut Context<'static, C>) -> C {
    C::from_u8(cxt.input().unwrap_or(0))
}

/// Runtime function. Print the given value to the output and return true if the output closed.
extern "sysv64" fn hpbf_context_output<C: CellType>(
    cxt: &mut Context<'static, u8>,
    value: C,
) -> bool {
    cxt.output(value.into_u8()).is_none()
}

executor_tests!(BaseJitCompiler);
same_as_inplace_tests!(BaseJitCompiler);
